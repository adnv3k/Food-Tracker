""""
A WORK IN PROGRESS
Access public api to get nutrition data for foods.
Input: food item, amount 
Output: nutrition for item for amount given

Things to consider as inputs:
souce/brandOwnder
    these can be wholefoods, smiths, etc

For recipes:
    get ingredients if possible, then cross reference with usda for nutrient facts

FEATURE: Keep a counter for current daily nutrition, and display which type, and how much nutrition is needed to fulfill the day's reccommended amount

FEATURE: Save recipes
    will need to input ingredients and amount
"""
import os
import sys
from typing import Any, AnyStr
import requests
import shelve
import pandas as pd
import matplotlib.pyplot as plt
# when polling from more than two datasets, find the standard deviation as a measurment of average value validity
#USDA key
"""
/food/{fdcId}	GET	Fetches details for one food item by FDC ID
/foods	GET | POST	Fetches details for multiple food items using input FDC IDs
/foods/list	GET | POST	Returns a paged list of foods, in the 'abridged' format
/foods/search	GET | POST	Returns a list of foods that matched search (query) keywords

SR Legacy Foods
Data on food components, including nutrients, that are derived from
analyses, calculations, and the published literature for a comprehensive list of foods.
SR Legacy, released in April 2018, is the final release of this data type and will not be updated.

Branded Foods
Public-private partnership provides nutrient data that appear on branded
and private label foods generated by the food industry.
Branded Foods are updated monthly.

"""

"""
Progress so far:
Have daily nutritional goals for m/f in age range 2-51+
data is stored in usda['daily_nutrition']

To retrieve...
Getting daily rec for age and sex
age = 32
sex = "M"
for age_range in [*daily[sex]]:
    if age in range(age_range[0],age_range[1]+1):
        daily_nutrition = daily[sex][age_range]
        print(daily[sex][age_range])

Stored in daily_nutrition

"""
# TODO
# Profile info reception
#
# If cant find acceptable entries return list of potential entries
# 
# Figure out how to handle searches 
#
# things to try:
#   filtering based on last updated (e.g. recent 5 years)
#
#   regex search
#
#   getting a standard deviation
#   if sd too high, then sort values,
#   then remove values that are furthest away from clustered values
#   until sd is acceptable
#
#   choosing a group based on critera:
#       percent difference:
#           if a value is within 0.9 * selected_value or 1.1 * selected_value then include it in the group
#
#   subtract food entry nutrients from current daily total
#       process daily_nutrition_bank so that values can be subtracted
#           unit names are stored with the name

# usda_key = os.environ['usda_nutrition']
usda_key = '0arBG94hGw3XyzanWdsZ4I6dTCmsT1aj7QWSJkGf'
# To get pages in a range
# 
# for page in range(1,51):
    # url = f'https://api.nal.usda.gov/fdc/v1/foods/list?api_key={usda_key}&pageSize=200&pageNumber={page}'
    # response = requests.get(url)
    # json = response.json()
    # print(response)
    # file = shelve.open('usda_pages')
    # file[str(page)] = json
    # file.close()

# To get specific page
#  
# page = 101
# url = f'https://api.nal.usda.gov/fdc/v1/foods/list?api_key={usda_key}&pageSize=200&pageNumber={page}'
# response = requests.get(url)
# json = response.json()
# print(response)
# file = shelve.open('usda_pages')
# file[str(page)] = json
# file.close()


# DELETE trying to get other pages
# page = 51
# query = 'chicken'
# url = f'https://api.nal.usda.gov/fdc/v1/foods/list?api_key={usda_key}&pageSize=200&pageNumber={page}&sortBy=lowercaseDescription.keyword&sortOrder=desc'
# url = f'https://api.nal.usda.gov/fdc/v1/foods/search?api_key={usda_key}&query={query}&pageSize=200'
# url = f'https://api.nal.usda.gov/fdc/v1/foods/list?api_key={usda_key}&pageSize=200&pageNumber={page}'

# SR Legacy datatype
# url = f'https://api.nal.usda.gov/fdc/v1/foods/search?api_key={usda_key}&query={query}&dataType=SR%20Legacy&pageSize=200'
# Branded datatype
# url = f'https://api.nal.usda.gov/fdc/v1/foods/search?api_key={usda_key}&query={query}&dataType=Branded&pageSize=200'
# Both 
# url = f'https://api.nal.usda.gov/fdc/v1/foods/search?api_key={usda_key}&query={query}&dataType=Branded,SR%20Legacy&pageSize=200'

#
# response = requests.get(url)
# print(response.headers)
# json = response.json()
# print(response)
# print(json.keys())
# print(len(json))
# print(f'totalhits: {json["totalHits"]}')
# print(f'totalpages: {json["totalPages"]}')
# f=shelve.open[98]

# file = shelve.open('delete')
# file[str(page)] = json
# file.close()
# file = shelve.open('delete')
# json = file[str(page)]
# file.close()
# file = shelve.open('delete')
# file['other51'] = json 
# file['squid'] = response
# file.close()
# file = shelve.open('delete')
# json = file['other51']
# file.close()
# f=shelve.open[98]

# file = shelve.open('delete')
# file['list'] = json 
# file.close()
# file = shelve.open('delete')
# json = file['list']
# file.close()

# print(len(json))
# f=shelve.open[2]


#
# for entry in range(len(json)):
#     print(json['foods'][entry]['description'])
#
# df = pd.DataFrame(json['foods'])
# print(json['foods'][1].keys())
# print(json['foods'][1]['foodNutrients'])
# print(json['foods'][1]['foodNutrients'][22])
# print(df)

# for nutrient in range(len(json['foods'][1]['foodNutrients'])):
#     print(json['foods'][1]['foodNutrients'][nutrient]['nutrientName'])

# df = pd.DataFrame(json['foods'][1]['foodNutrients'])
# print(df.)

def test():
    food_item = 'udon'
    file = shelve.open('delete')
    json = file['other50']
    compare = {}
    compare["total_entries"] = 0
    compare["total_energy"] = 0
    compare["total_carbs"] = 0
    skip = ["Nong Shim Co., Ltd.", "Nasoya Foods USA, LLC", "United Natural Foods, Inc."]
    # print(json)
    # print(len(json))
    # f = shelve.open[3]
    for entry in range(len(json)):
        if json['foods'][entry]['brandOwner'] in skip:
            continue
        if food_item in json['foods'][entry]['description'].lower():
            # print(json['foods'][entry]['description'],end=" | ")
            # print(json['foods'][entry]['brandOwner'])
            # print(json['foods'][entry].keys())
            # print(len(json['foods'][entry]['foodNutrients']))
            # print(json['foods'][entry]['foodNutrients'])
                    # compare[f'{json["foods"][entry]["description"]}|{json["foods"][entry]["brandOwner"]}'] = 
            for element in json['foods'][entry]['foodNutrients']:
                if element['nutrientName'] == 'Carbohydrate, by difference':
                    compare["total_entries"] += 1
                    compare['total_carbs'] += element["value"]
                if element['nutrientName'] == 'Energy':
                    compare["total_energy"] += element["value"]
    avg_carbs = compare['total_carbs']/compare["total_entries"]
    avg_energy = compare['total_energy']/compare["total_entries"]
    print(f'Average Carbs: {avg_carbs} | Average Energy: {avg_energy}')
    for entry in range(len(json)):
        if json['foods'][entry]['brandOwner'] in skip:
            continue
        if food_item in json['foods'][entry]['description'].lower():
            print(json['foods'][entry]['description'],end=" | ")
            print(json['foods'][entry]['brandOwner'])
            for element in json['foods'][entry]['foodNutrients']:
                if element['nutrientName'] == 'Carbohydrate, by difference':
                    print(f'Carbohydrate, by difference: {element["value"]} {element["unitName"]} | Percent difference from avg: {round((abs(element["value"]-avg_carbs)/avg_carbs)*100,2)}')
                if element['nutrientName'] == 'Energy':
                    print(f'Energy: {element["value"]} {element["unitName"]} | Percent difference from avg: {round((abs(element["value"]-avg_energy)/avg_energy)*100,2)}')
    # df = pd.DataFrame(json['foods'][entry]['foodNutrients'])
    # print(df)
        file.close()

# file = shelve.open('delete')
# json = file['other51']
# for key in [*json]:
#     if key == 'foods':
#         print(f'Amount of results:\n{len(json[key])}')
#         continue
#     print(f'{key}')
#     print(f'{json[key]}')
# print(json['foods'][0]['foodNutrients'])

# file = shelve.open('usda')
# nutrients = file['nutrientNames']
# file.close()
# print(len(nutrients))

# for entry in [*json['foods']]:
#     for ele in entry['foodNutrients']:
#         if ele['nutrientName'] not in nutrients:
#             nutrients.append(ele['nutrientName'])

# nutrients.sort()

# file = shelve.open('usda')
# file['nutrientNames'] = nutrients 
# file.close()

# print(nutrients)
# for ele in nutrients:
#     print(ele)
# print(len(nutrients))
# df = pd.DataFrame(nutrients)
# print(df)
# for entry in [*json['foods']]:
#     for element in entry["foodNutrients"]:
#         print(len(entry["foodNutrients"]))
        # print(element['nutrientName'])
# f=shelve.open[2]

# skip = ["organic","and","soup", "spicy", "&", "chicken", "beef", "rice", "pasta","chlorella", "miso","ginger","soy","tempura","shoyu","sanuki", "bowl"]
# skip = []
def holder():
    food_item = 'chicken'
    total_weight = {}
    data = {}
    data['percent_carbs'] = []
    for entry in [*json["foods"]]:
        # go = False
        # for ele in skip:
        #     if ele in entry['description'].lower():
        #         go = True
        # if go:
        #     continue
        if food_item in entry['description'].lower():
            total_weight["G"] = 0
            total_weight["MG"] = 0
            # print([*entry])
            # print(entry["foodNutrients"])
            for element in entry["foodNutrients"]:
                # print(element["unitName"])
                if element["nutrientName"] == "Carbohydrate, by difference":
                    carbs = element["value"]
                if element["unitName"] in [*total_weight]:
                    total_weight[element["unitName"]] += element['value']
            total = round(total_weight["G"]+(total_weight["MG"]/1000),2)
            percent_carbs = round((carbs/total)*100,2)
            data['percent_carbs'].append(percent_carbs)
            print(entry['description'])
            print(f'Total mass: {total} G | Percent Carbs: {percent_carbs}')
    # data["percent_carbs"].sort()
    # print(data["percent_carbs"])
    print(f'Highest Value: {max(data["percent_carbs"])}')
    print(f'Lowest Value: {min(data["percent_carbs"])}')
    print(f'Average Value: {round(sum(data["percent_carbs"])/len(data["percent_carbs"]),2)}')
    print(len(data["percent_carbs"]))
    # print(data["percent_carbs"])
    # data["percent_carbs"].remove(64.24)
    # print(f'Highest Value: {max(data["percent_carbs"])}')
    # print(f'Lowest Value: {min(data["percent_carbs"])}')
    # print(f'Average Value: {sum(data["percent_carbs"])/len(data["percent_carbs"])}')
    df = pd.DataFrame(data["percent_carbs"])
    print(df.mean())

    # Plotting
    x_axis = []
    for i in range(len(data["percent_carbs"])):
        x_axis.append(i)
    #
    y_axis = data["percent_carbs"]
    #
    # plt.scatter(x_axis, y_axis)
    # plt.ylabel('Percent Compositions')
    # plt.xlabel('Range')
    plt.scatter(y_axis, x_axis)
    plt.xlabel('Percent Compositions')
    plt.ylabel('')
    #
    plt.show()



# Evaluate search results for x nutrient composition
class USDA(object):
    """
    Acts like an API wrapper for USDA nutrition API.
    Requires API key for arguement: str
    """
    def __init__(self, key: AnyStr) -> None:
        super().__init__()
        self.key = key
        self.unit_names_bank = self.get_unit_names_bank()
        self.total_mass = {}
        self.nutrient_compositions = {}
        self.nutrients = None
        self.descriptions = None
    
    def search(self, query, data_type=f'SR%20Legacy',file_name='delete'):
        """
        Search the USDA nutrition API
        query: string
        data_type: string
        Acceptable data_types: "SR%20Legacy" (default) and "Branded"

        Returns: requests object
        """
        if not self.is_saved(file_key=query,file_name=file_name):
            url = f'https://api.nal.usda.gov/fdc/v1/foods/search?api_key={self.key}&query={query}&dataType={data_type}&pageSize=200'
            response = requests.get(url)
            if not response.ok:
                return f'{response.status_code}'
            print(response)
            self.save(item=response,file_key=query,file_name=file_name)
        
        response = self.get(file_key=query,file_name=file_name)
        json = response.json()
        print(
            f'Query: {query}\n'
            f'Total Hits: {json["totalHits"]}\n'
            f'Total Pages: {json["totalPages"]}'
            )
        self.results = json['foods']
        return response
    def save(self, item: Any, file_key: str, file_name:str='delete'):
        """
        item: anything
        file_key: string
        """
        file = shelve.open(file_name)
        file[file_key] = item
        file.close()
        print('Saved')
    def get(self, file_key: str, file_name:str='delete'):
        file = shelve.open(file_name)
        item = file[file_key]
        file.close()
        return item
    def is_saved(self, file_key, file_name):
        file = shelve.open(file_name)
        try:
            if file[file_key]:
                file.close()
                return True
        except:
            file.close()
            return False

    def get_results(self):
        # print([*self.results[0]]) # delete 
        return self.results

    def get_descriptions(self):
        descriptions = []
        for result in self.results:
            descriptions.append(result['description'])
        # print(descriptions)
        self.descriptions = descriptions
        return descriptions
    def get_nutrient_names(self, nutrients: dict = None) -> list[str]:
        nutrient_names = []
        if nutrients:
            for nutrient in nutrients[[*nutrients][0]]:
                nutrient_names.append(nutrient['nutrientName'])
            return nutrient_names
        for result in self.results:
            for nutrient in result['foodNutrients']:
                if nutrient['nutrientName'] not in nutrient_names:
                    nutrient_names.append(nutrient['nutrientName'])
        # print(nutrient_names)
        return nutrient_names
    def get_nutrients(self, description=None):
        """
        Input: description: str

        Output: nutrients: dict[list]

        If description is specified, then returns nutrients[description] = [dict, ...]
        
        Else returns nutrients[every description in self.results] = [dict, ...]
        """
        if self.nutrients:
            return self.nutrients
        nutrients = {}
        for result in self.results:
            name = result['description']
            nutrients[name] = []
            for nutrient in result['foodNutrients']:
                nutrients[name].append(
                    {
                        'nutrientName': nutrient['nutrientName'],
                        'value': nutrient['value'],
                        'unitName': nutrient['unitName'],
                        'nutrientId': nutrient['nutrientId']
                    })
        self.nutrients = nutrients
        # print(nutrients)
        return nutrients

    def get_total_mass(self, description):
        if description in self.total_mass: 
            return self.total_mass[description]
        nutrients = self.get_nutrients(description)[description]
        mass = 0
        for nutrient in nutrients:
            grams = self.convert_to_grams(nutrient['value'], nutrient['unitName'])
            if grams:
                mass += grams
        return round(mass, 3)

    def get_nutrient_composition(self, description: str, nutrient: str):
        """
        Returns percent composition of nutrient for description
        """
        # if compositions dict doesnt have description key
        # then this has not been run before, and there is no 
        # nutrient key with percent value
        # so create empty dict for description key
        # if description key does exit (else)
        # then there could be nutrient with percent
        # if so return percent for description and nutrient
        if not self.nutrient_compositions.get(description): 
            self.nutrient_compositions[description] = {}
        elif self.nutrient_compositions.get(description).get(nutrient):
            return self.nutrient_compositions[description][nutrient]

        total_mass = self.get_total_mass(description)
        nutrients = self.get_nutrients(description)[description]

        for entry in nutrients:
            if entry['nutrientName'] == nutrient:
                grams = self.convert_to_grams(entry['value'], entry['unitName'])
                if grams:
                    percent = grams/total_mass*100
                    percent = round(grams/total_mass*100, 3)
                    self.nutrient_compositions[description][nutrient] = percent
                    return percent # Percent composition
    def get_nutrient_composition_profile(self, description: str):
        """
        Returns nutrientName with its percent composition
        """
        
        total_mass = self.get_total_mass(description)

        unsorted_profile = {}
        not_included = [] # TODO make function to convert every unit in unit bank to g
        nutrients = self.get_nutrients(description)[description]
        
        for nutrient in nutrients:
            grams = self.convert_to_grams(nutrient['value'], nutrient['unitName'])
            if not grams:
                not_included.append(
                    (
                        nutrient['nutrientName'], 
                        nutrient['value']
                        # f'{nutrient["value"]} {nutrient["unitName"]}'
                        ))
                continue

            perc = round(grams/total_mass*100, 3)
            perc = grams/total_mass*100

            if unsorted_profile.get(perc):
                unsorted_profile[perc].append(nutrient['nutrientName'])
            else:
                unsorted_profile[perc] = [nutrient['nutrientName']]
        
        # Returns dict
        # profile = {}
        # sorted_percents = [*unsorted_profile]
        # sorted_percents.sort()
        # for percent in sorted_percents[::-1]:
        #     for nutrient_name in unsorted_profile[percent]:
        #         profile[nutrient_name] = percent
        # return profile
        
        # Returns tuple
        profile = []
        sorted_percents = [*unsorted_profile]
        sorted_percents.sort()
        for percent in sorted_percents[::-1]:
            for nutrient_name in unsorted_profile[percent]:
                profile.append((
                    nutrient_name, percent
                    ))
        return profile, not_included

    def convert_to_grams(self, value: int, unit: str):
        """
        Returns False if unit is not mg, ug, or g.
        """
        unit = unit.lower()
        if unit == 'mg':
            return value*10**(-3)
        elif unit == 'ug':
            return value*10**(-6)
        elif unit == 'g':
            return value
        else:
            return False
    def convert_to_calories(self, value, unit):
        unit = unit.lower()
        if unit == 'kj':
            return value/4.184

    def get_nutrient_names_bank(self):
        file = shelve.open('usda')
        bank = file['nutrient_names_bank']
        file.close()
        return bank
    def get_unit_names_bank(self):
        file = shelve.open('usda')
        bank = file['unit_names_bank']
        file.close()
        return bank
    def get_daily_nutrition(self, age: int = 1, sex: str = "") -> dict:
        """
        Age: int > 1
        Returns the daily recommended nutrition given sex and age.
        If no arguments supplied, returns entire table.
        """
        # Get table data
        file = shelve.open('usda')
        daily_nutrition_bank = file['daily_nutrition']
        file.close()
        
        if not age or not sex: # No arguments given
            return daily_nutrition_bank

        # Converts sex to correct format
        sex = sex[0].upper()

        for age_range in [*daily_nutrition_bank[sex]]:
            if age in range(age_range[0], age_range[1]+1):
                return daily_nutrition_bank[sex][age_range]


    def eval_nutrient_composition(self, food_item):
        food_item = 'bread'
        total_weight = {}
        data = {}
        data['percent_carbs'] = []
        for entry in [*json["foods"]]:
            if food_item in entry['description'].lower():
                total_weight["G"] = 0
                total_weight["MG"] = 0
                for element in entry["foodNutrients"]:
                    if element["nutrientName"] == "Carbohydrate, by difference":
                        carbs = element["value"]
                    if element["unitName"] in [*total_weight]:
                        total_weight[element["unitName"]] += element['value']
                total = round(total_weight["G"]+(total_weight["MG"]/1000),2)
                percent_carbs = round((carbs/total)*100,2)
                data['percent_carbs'].append(percent_carbs)
                print(entry['description'])
                print(f'Total mass: {total} G | Percent Carbs: {percent_carbs}')
        print(f'Highest Value: {max(data["percent_carbs"])}')
        print(f'Lowest Value: {min(data["percent_carbs"])}')
        print(f'Average Value: {round(sum(data["percent_carbs"])/len(data["percent_carbs"]),2)}')
        print(len(data["percent_carbs"]))
        df = pd.DataFrame(data["percent_carbs"])
        print(df.mean())

def percent_difference():
    pass

# Print functions 
# usda_pages save/open
# file = shelve.open('usda_pages')
# file[str(page)] = json
# file.close()
# file = shelve.open('usda_pages')
# json = file['16']
# file.close()

# print(json)
# print(json[0])
# print(len(json))
# print(list(json.keys()))
# print(len(json.keys()))
# print(json['foods'])
# print(len(json['foods']))
# print(json['foods'][6]['description'])

# For entry iteration
# for entry in range(len(json)):
#     print(json[entry]['description'])

# Specific item search
# food_item = 'chicken sandwich'
# for page in range(1,51):
#     file = shelve.open('usda_pages')
#     json = file[f'{page}']
#     for entry in range(len(json)):
#         if food_item in json[entry]['description'].lower():
#             print(json[entry]['description'])
#             df = pd.DataFrame(json[entry]['foodNutrients'])
#             print(df)
#     file.close()
